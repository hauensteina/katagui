{% extends 'layout.tmpl' %}

{% block css %}
<meta name='viewport' content='width=device-width, initial-scale=1'>
<style>
</style>
{% endblock css %}

{% block content %}
<div id='boardDiv'
  style='width:90vw;height:90vw;margin-left:auto;margin-right:auto;'>
</div>
<div>
  <button onclick="exportDiagram()">Export</button>
</div>

{% endblock content %}

{% block js %}
<script>
  'use strict'
  const BLACK = 1
  const WHITE = 2
  const EMPTY = 0
  const TRIANGLE = '/'
  const CIRCLE = '0'

  var g_stonesJson = '{{ stones }}'
  var g_marksJson = '{{ marks }}'
  var g_stones = JSON.parse(g_stonesJson)
  var g_marks = JSON.parse(g_marksJson)
  var g_blackStones = []
  var g_whiteStones = []
  var g_mincol = 0
  var g_maxcol = 18
  var g_minrow = 0
  var g_maxrow = 18
  var g_boardDiv = document.getElementById('boardDiv')
  // Create canvas element
  const outerSize = parseInt(g_boardDiv.clientWidth)
  const g_canvas = document.createElement('canvas')
  g_canvas.width = outerSize
  g_canvas.height = outerSize
  g_boardDiv.appendChild(g_canvas)

  // Get black and white stones into lists
  for (var i = 0; i < g_stones.length; i++) {
    var row = g_stones[i]
    for (var j = 0; j < row.length; j++) {
      var stone = row[j]
      if (stone == 1) {
        g_blackStones.push({ x: j, y: i })
      } else if (stone == 2) {
        g_whiteStones.push({ x: j, y: i })
      }
    } // for 
  } // for 

  $(function () {
    drawGoBoard(g_canvas, g_blackStones, g_whiteStones, g_marks, g_minrow, g_maxrow, g_mincol, g_maxcol)
  })

  //--------------------------------
  function exportDiagram() {
    const canvas = document.createElement('canvas')
    canvas.width = 1500
    canvas.height = 1500
    drawGoBoard(canvas, g_blackStones, g_whiteStones, g_marks, g_minrow, g_maxrow, g_mincol, g_maxcol)
    var dataURL = canvas.toDataURL('image/png')
    var link = document.createElement('a')
    link.download = 'diagram.png'
    link.href = dataURL
    document.body.appendChild(link)
    link.click()
    document.body.removeChild(link)
  } // exportDiagram()

  // Function to draw the board position and hilight a specified area
  //--------------------------------------------------------------------------------------------------------------
  function drawGoBoard(canvas, blackStones, whiteStones, marks, minRow, maxRow, minCol, maxCol) {
    const boardSize = 19
    //const outerDiv = document.getElementById('outerDiv')
    // Without padding
    const outerSize = canvas.width
    const marg = outerSize * 0.05
    const boardPixelSize = outerSize - 2 * marg

    const tileSize = boardPixelSize / (boardSize - 1)
    const wSstoneRadius = tileSize * 0.45
    const bSstoneRadius = tileSize * 0.45
    const wStoneStrokeWidth = tileSize * 0.05
    const bStoneStrokeWidth = tileSize * 0.05
    const hoshiRadius = tileSize / 6 // Radius of the handicap points
    const highlightColor = 'lightblue'
    const edgeLineWidth = tileSize * 0.18
    const innerLineWidth = tileSize * 0.08

    //----------------------
    function sx(col) {
      return marg + col * tileSize
    }

    //---------------------
    function sy(row) {
      return marg + row * tileSize
    }

    // Handicap points (hoshis) for a 19x19 board
    const hoshis = [{ x: 3, y: 3 }, { x: 3, y: 9 }, { x: 3, y: 15 }, { x: 9, y: 3 }, { x: 9, y: 9 }, { x: 9, y: 15 }, { x: 15, y: 3 }, { x: 15, y: 9 }, { x: 15, y: 15 }]

    const ctx = canvas.getContext('2d')
    const markFont = fittingFont(tileSize * 0.8)

    // Highlight specified area
    ctx.fillStyle = highlightColor;
    ctx.fillRect(sx(minCol) - tileSize / 2, sy(minRow) - tileSize / 2,
      (maxCol - minCol + 1) * tileSize, (maxRow - minRow + 1) * tileSize)

    // Draw the grid
    for (let i = 0; i < boardSize; i++) {
      ctx.beginPath()
      ctx.lineWidth = (i === 0 || i === boardSize - 1) ? edgeLineWidth : innerLineWidth
      //vertical
      ctx.moveTo(sx(i), sy(0))
      ctx.lineTo(sx(i), sy(boardSize - 1))
      // horizontal
      ctx.moveTo(sx(0) - edgeLineWidth / 2, sy(i))
      ctx.lineTo(sx(boardSize - 1) + edgeLineWidth / 2, sy(i))
      ctx.stroke()
    }

    // Function to draw a stone
    //-------------------------------------
    function drawStone(x, y, color) {
      var stoneRadius = (color == 'black') ? bSstoneRadius : wSstoneRadius
      if (color == 'black') {
        ctx.lineWidth = bStoneStrokeWidth
      } else {
        ctx.lineWidth = wStoneStrokeWidth
      }
      ctx.beginPath()
      ctx.arc(sx(y), sy(x), stoneRadius, 0, 2 * Math.PI)
      ctx.fillStyle = color
      ctx.fill()
      ctx.stroke()
    } // drawStone()

    // Draw handicap points (hoshis)
    hoshis.forEach(hoshi => {
      ctx.beginPath()
      ctx.arc(sx(hoshi.x), sy(hoshi.y), hoshiRadius, 0, 2 * Math.PI)
      ctx.fillStyle = 'black'
      ctx.fill()
    });

    // Draw black stones
    blackStones.forEach(stone => drawStone(stone.x, stone.y, 'black'))

    // Draw white stones
    whiteStones.forEach(stone => drawStone(stone.x, stone.y, 'white'))

    // draw marks
    for (var i = 0; i < marks.length; i++) {
      var row = marks[i]
      for (var j = 0; j < row.length; j++) {
        var mark = row[j]
        if (mark.length > 0) {
          if (mark == '0') {
            drawCircle(j, i)
          } else if (mark == '/') {
            drawTriangle(j, i)
          } else {
            drawLetter(j, i, mark)
          }
        }
      } // for
    } // for

    //--------------------------------------
    function drawCircle(x, y) {
      var lineWidth = tileSize * 0.04
      var radius = tileSize * 0.25
      var color = 'black'
      if (g_stones[y][x] == BLACK) {
        color = 'white'
        lineWidth = tileSize * 0.1
      }
      ctx.strokeStyle = color
      ctx.lineWidth = lineWidth
      ctx.beginPath()
      ctx.arc(sx(y), sy(x), radius, 0, 2 * Math.PI)
      ctx.stroke()
    } // drawCircle()

    //---------------------------------
    function drawTriangle(x, y) {
      var cos120 = -0.5
      var sin120 = 0.86602540378
      var r = tileSize * 0.45
      var p0 = { x: 0, y: r }
      var p1 = { x: sin120 * r, y: cos120 * r }
      var p2 = { x: -sin120 * r, y: cos120 * r }
      var lineWidth = tileSize * 0.05
      var color = 'black'
      if (g_stones[y][x] == BLACK) {
        color = 'white'
        lineWidth = tileSize * 0.1
      }
      ctx.strokeStyle = color
      ctx.lineWidth = lineWidth
      ctx.beginPath()
      ctx.moveTo(sx(y) + p0.x, sy(x) - p0.y)
      ctx.lineTo(sx(y) + p1.x, sy(x) - p1.y)
      ctx.lineTo(sx(y) + p2.x, sy(x) - p2.y)
      //ctx.moveTo(sx(y)+p0.y, sy(x)+p0.x)
      ctx.closePath()
      ctx.stroke()
    } // drawTriangle()

    //---------------------------- 
    function fittingFont(s) {
      var fontSize = 50 // Start with a large font size
      var font = ''

      while (true) {
        font = fontSize + "px Arial"; // Set the font size and type
        var textWidth = ctx.measureText('a').width
        var textHeight = fontSize // Assume letter height is equal to font size

        // Check if the letter dimensions fit within the circle's diameter
        if (textWidth <= s && textHeight <= s) {
          return font
        }

        fontSize--
        if (fontSize <= 1) {
          break
        }
      } // while
      return font
    } // fittingFont()

    //------------------------------------
    function drawLetter(x, y, letter) {
      ctx.font = markFont
      ctx.fillStyle = 'black'
      if (g_stones[y][x] == BLACK) {
        ctx.fillStyle = 'white'
      }
      ctx.textAlign = 'center'
      ctx.textBaseline = 'middle'
      ctx.fillText(letter, sx(y), sy(x))
    } // drawLetter


  } // drawGoBoard()

</script>
{% endblock js %}